import numpy

from common.definitions import idx_h, idx_hu1, idx_hu2, gravity

def rhs_sw (Q: numpy.ndarray, geom, mtrx, metric, topo, ptopo, nbsolpts: int, nb_elements_hori: int):

   type_vec = Q.dtype
   nb_equations = Q.shape[0]
   nb_interfaces_hori = nb_elements_hori + 1

   df1_dx1, df2_dx2, flux_x1, flux_x2 = [numpy.empty_like(Q, dtype=type_vec) for _ in range(4)]

   flux_x1_itf_i = numpy.empty((nb_equations, nb_elements_hori+2, nbsolpts*nb_elements_hori, 2), dtype=type_vec)
   flux_x2_itf_j, var_itf_i, var_itf_j= [numpy.empty((nb_equations, nb_elements_hori+2, 2, nbsolpts*nb_elements_hori), dtype=type_vec) for _ in range(3)]

   forcing = numpy.zeros_like(Q, dtype=type_vec)

   # Offset due to the halo
   offset = 1

   # Unpack dynamical variables
   HH = Q[idx_h] if topo is None else Q[idx_h] + topo.hsurf
   u1 = Q[idx_hu1] / Q[idx_h]
   u2 = Q[idx_hu2] / Q[idx_h]

   # Interpolate to the element interface
   for elem in range(nb_elements_hori):
      epais = elem * nbsolpts + numpy.arange(nbsolpts)
      pos   = elem + offset

      # --- Direction x1

      var_itf_i[idx_h, pos, 0, :] = HH[:, epais] @ mtrx.extrap_west
      var_itf_i[idx_h, pos, 1, :] = HH[:, epais] @ mtrx.extrap_east

      var_itf_i[1:, pos, 0, :] = Q[1:, :, epais] @ mtrx.extrap_west
      var_itf_i[1:, pos, 1, :] = Q[1:, :, epais] @ mtrx.extrap_east

      # --- Direction x2
      var_itf_j[idx_h, pos, 0, :] = mtrx.extrap_south @ HH[epais, :]
      var_itf_j[idx_h, pos, 1, :] = mtrx.extrap_north @ HH[epais, :]

      var_itf_j[1:, pos, 0, :] = mtrx.extrap_south @ Q[1:, epais, :]
      var_itf_j[1:, pos, 1, :] = mtrx.extrap_north @ Q[1:, epais, :]

   # Initiate transfers
   all_request = ptopo.xchange_sw_interfaces(geom, var_itf_i[idx_h], var_itf_j[idx_h], var_itf_i[idx_hu1], var_itf_i[idx_hu2], var_itf_j[idx_hu1], var_itf_j[idx_hu2], blocking=False)

   # Compute the fluxes
   flux_x1[idx_h] = metric.sqrtG * Q[idx_hu1]
   flux_x2[idx_h] = metric.sqrtG * Q[idx_hu2]

   hsquared = Q[idx_h]**2
   flux_x1[idx_hu1] = metric.sqrtG * ( Q[idx_hu1] * u1 + 0.5 * gravity * metric.H_contra_11 * hsquared )
   flux_x2[idx_hu1] = metric.sqrtG * ( Q[idx_hu1] * u2 + 0.5 * gravity * metric.H_contra_12 * hsquared )

   flux_x1[idx_hu2] = metric.sqrtG * ( Q[idx_hu2] * u1 + 0.5 * gravity * metric.H_contra_21 * hsquared )
   flux_x2[idx_hu2] = metric.sqrtG * ( Q[idx_hu2] * u2 + 0.5 * gravity * metric.H_contra_22 * hsquared )

   # Interior contribution to the derivatives, corrections for the boundaries will be added later
   for elem in range(nb_elements_hori):
      epais = elem * nbsolpts + numpy.arange(nbsolpts)

      # --- Direction x1
      df1_dx1[:,:,epais] = flux_x1[:,:,epais] @ mtrx.diff_solpt_tr

      # --- Direction x2
      df2_dx2[:,epais,:] = mtrx.diff_solpt @ flux_x2[:,epais,:]

   # Finish transfers
   all_request.wait()

   # Substract topo after extrapolation
   if topo is not None:
      var_itf_i[idx_h] -= topo.hsurf_itf_i
      var_itf_j[idx_h] -= topo.hsurf_itf_j

   # Common Osher fluxes
   for itf in range(nb_interfaces_hori):

      elem_L = itf
      elem_R = itf + 1

      ################
      # Direction x1 #
      ################

      u1_L = var_itf_i[idx_hu1, elem_L, 1, :] / var_itf_i[idx_h, elem_L, 1, :]
      u1_R = var_itf_i[idx_hu1, elem_R, 0, :] / var_itf_i[idx_h, elem_R, 0, :]
      u2_L = var_itf_i[idx_hu2, elem_L, 1, :] / var_itf_i[idx_h, elem_L, 1, :]
      u2_R = var_itf_i[idx_hu2, elem_R, 0, :] / var_itf_i[idx_h, elem_R, 0, :]
      sqrt_h_L = numpy.sqrt(var_itf_i[idx_h, elem_L, 1, :])
      sqrt_h_R = numpy.sqrt(var_itf_i[idx_h, elem_R, 0, :])

      h_osher  = 1. / (4. * gravity * metric.H_contra_11_itf_i[itf, :]) * (0.5 * (u1_L - u1_R) + numpy.sqrt(gravity * metric.H_contra_11_itf_i[itf, :]) * (sqrt_h_L + sqrt_h_R))**2
      u1_osher = 0.5 * (u1_L + u1_R) + numpy.sqrt(gravity * metric.H_contra_11_itf_i[itf, :]) * (sqrt_h_L - sqrt_h_R)
      u2_osher = numpy.where(u1_osher >= 0., \
            u2_L + (metric.H_contra_12_itf_i[itf, :] / metric.H_contra_11_itf_i[itf, :]) * (0.5 * (u1_R - u1_L) + numpy.sqrt(gravity * metric.H_contra_11_itf_i[itf, :]) * (sqrt_h_L - sqrt_h_R)), \
            u2_R + (metric.H_contra_12_itf_i[itf, :] / metric.H_contra_11_itf_i[itf, :]) * (0.5 * (u1_L - u1_R) + numpy.sqrt(gravity * metric.H_contra_11_itf_i[itf, :]) * (sqrt_h_L - sqrt_h_R)) )
   
      # --- Advection part

      flux_x1_itf_i[idx_h  , elem_L, :, 1] = metric.sqrtG_itf_i[itf, :] * (u1_osher * h_osher)
      flux_x1_itf_i[idx_hu1, elem_L, :, 1] = metric.sqrtG_itf_i[itf, :] * (u1_osher * u1_osher * h_osher)
      flux_x1_itf_i[idx_hu2, elem_L, :, 1] = metric.sqrtG_itf_i[itf, :] * (u1_osher * u2_osher * h_osher)

      # --- Pressure part

      flux_x1_itf_i[idx_hu1, elem_L, :, 1] += 0.5 * metric.sqrtG_itf_i[itf, :] * gravity * metric.H_contra_11_itf_i[itf, :] * h_osher**2
      flux_x1_itf_i[idx_hu2, elem_L, :, 1] += 0.5 * metric.sqrtG_itf_i[itf, :] * gravity * metric.H_contra_21_itf_i[itf, :] * h_osher**2

      flux_x1_itf_i[:, elem_R, :, 0] = flux_x1_itf_i[:, elem_L, :, 1]

      ################
      # Direction x2 #
      ################

      u1_L = var_itf_j[idx_hu1, elem_L, 1, :] / var_itf_j[idx_h, elem_L, 1, :]
      u1_R = var_itf_j[idx_hu1, elem_R, 0, :] / var_itf_j[idx_h, elem_R, 0, :]
      u2_L = var_itf_j[idx_hu2, elem_L, 1, :] / var_itf_j[idx_h, elem_L, 1, :]
      u2_R = var_itf_j[idx_hu2, elem_R, 0, :] / var_itf_j[idx_h, elem_R, 0, :]
      sqrt_h_L = numpy.sqrt(var_itf_j[idx_h, elem_L, 1, :])
      sqrt_h_R = numpy.sqrt(var_itf_j[idx_h, elem_R, 0, :])
      
      h_osher  = 1. / (4. * gravity * metric.H_contra_22_itf_j[itf, :]) * (0.5 * (u2_L - u2_R) + numpy.sqrt(gravity * metric.H_contra_22_itf_j[itf, :]) * (sqrt_h_L + sqrt_h_R))**2
      u2_osher = 0.5 * (u2_L + u2_R) + numpy.sqrt(gravity * metric.H_contra_22_itf_j[itf, :]) * (sqrt_h_L - sqrt_h_R)
      u1_osher = numpy.where(u2_osher >= 0., \
            u1_L + (metric.H_contra_12_itf_j[itf, :] / metric.H_contra_22_itf_j[itf, :]) * (0.5 * (u2_R - u2_L) + numpy.sqrt(gravity * metric.H_contra_22_itf_j[itf, :]) * (sqrt_h_L - sqrt_h_R)), \
            u1_R + (metric.H_contra_12_itf_j[itf, :] / metric.H_contra_22_itf_j[itf, :]) * (0.5 * (u2_L - u2_R) + numpy.sqrt(gravity * metric.H_contra_22_itf_j[itf, :]) * (sqrt_h_L - sqrt_h_R)) )
   
      # --- Advection part

      flux_x2_itf_j[idx_h, elem_L, 1, :]   = metric.sqrtG_itf_j[itf, :]  * (u2_osher * h_osher)
      flux_x2_itf_j[idx_hu1, elem_L, 1, :] = metric.sqrtG_itf_j[itf, :]  * (u1_osher * u2_osher * h_osher)
      flux_x2_itf_j[idx_hu2, elem_L, 1, :] = metric.sqrtG_itf_j[itf, :]  * (u2_osher * u2_osher * h_osher)

      # --- Pressure part

      flux_x2_itf_j[idx_hu1, elem_L, 1, :] += 0.5 * metric.sqrtG_itf_j[itf, :]  * gravity * metric.H_contra_12_itf_j[itf, :] * h_osher**2
      flux_x2_itf_j[idx_hu2, elem_L, 1, :] += 0.5 * metric.sqrtG_itf_j[itf, :]  * gravity * metric.H_contra_22_itf_j[itf, :] * h_osher**2

      flux_x2_itf_j[:, elem_R, 0, :] = flux_x2_itf_j[:, elem_L, 1, :]


   # Compute the derivatives
   for elem in range(nb_elements_hori):
      epais = elem * nbsolpts + numpy.arange(nbsolpts)

      # --- Direction x1

      df1_dx1[:,:,epais] += flux_x1_itf_i[:, elem+offset,:,:] @ mtrx.correction_tr

      # --- Direction x2

      df2_dx2[:,epais,:] += mtrx.correction @ flux_x2_itf_j[:, elem+offset,:,:]

   if topo is None:
      topo_dzdx1 = numpy.zeros_like(metric.H_contra_11)
      topo_dzdx2 = numpy.zeros_like(metric.H_contra_11)
   else:
      topo_dzdx1 = topo.dzdx1
      topo_dzdx2 = topo.dzdx2

   # Add coriolis, metric and terms due to varying bottom topography
   # Note: christoffel_1_22 and metric.christoffel_2_11 are zero
   forcing[idx_hu1,:,:] = 2.0 * ( metric.christoffel_1_01 * Q[idx_hu1] + metric.christoffel_1_02 * Q[idx_hu2]) \
         + metric.christoffel_1_11 * Q[idx_hu1] * u1 + 2.0 * metric.christoffel_1_12 * Q[idx_hu1] * u2 \
         + gravity * Q[idx_h] * ( metric.H_contra_11 * topo_dzdx1 + metric.H_contra_12 * topo_dzdx2)

   forcing[idx_hu2,:,:] = 2.0 * (metric.christoffel_2_01 * Q[idx_hu1] + metric.christoffel_2_02 * Q[idx_hu2]) \
         + 2.0 * metric.christoffel_2_12 * Q[idx_hu1] * u2 + metric.christoffel_2_22 * Q[idx_hu2] * u2 \
         + gravity * Q[idx_h] * ( metric.H_contra_21 * topo_dzdx1 + metric.H_contra_22 * topo_dzdx2)

   # Assemble the right-hand sides
   rhs = metric.inv_sqrtG * - ( df1_dx1 + df2_dx2 ) - forcing

   return rhs
